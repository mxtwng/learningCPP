#include <vector>
#include <bit>
#include <bitset>
#include <algorithm>
#include <cmath>
using namespace std;

// max-subArray
int kadane(vector<int> arr) {
    int maxSum = arr[0], curSum = arr[0];
    for (int& i : arr) {
        curSum = max(i, curSum + i);
        maxSum = max(curSum, maxSum);
    }
    return maxSum;
}

// maxLength-subArray
int MLS_Swindow(vector<int>& arr) {
    if (arr.empty()) return 0;
    int i = 0, j = 0, iMax = -1, maxLen = 1, curLen = 1, n = arr.size();
    while (i < n && j < n) {
        while (j < n - 1 && arr[j] == arr[j+1] + 1) {
            i++;
            curLen++;
        }
        if (curLen > maxLen) {
            maxLen = curLen;
            iMax = i;
        }
        i = j + 1;
        curLen = 1;
    }
}

int EuclidGCD(int a, int b) {
    if (b == 0)
        return a;
    else
        return EuclidGCD(b, a%b);
}
// binaryGCD O(log min(a,b))
int Stein(int a, int b) {
    if (!a || !b) return a|b;
    int shift = countr_zero((unsigned int)a|b);
    a >>= countr_zero((unsigned int) a);
    while (b) {
        b >>= countr_zero((unsigned int) b);
        if (a > b) swap(a, b);
        b -= a;
    }
    return a << shift;
}

// Sieve of Eratosthenes O(nloglogn) n<=1e7
vector<int> primeSieve(int n) {
    vector<bool> is_prime(n+1, true);
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i * i <= n; i++) {
        if (is_prime[i]) {
            for (int j = i * i; j <= n; j += i)
                is_prime[j] = false;
        }
    }
    vector<int> primes;
    for (int i = 2; i <= n; i++) {
        if (is_prime[i]) primes.push_back(i);
    }
    return primes;
}

// Euler Sieve O(n) n around 1e7 1e8
// Also builds SPF (smallest prime factor) for factorization
//vector<int> spf(n+1, 0);
vector<int> EulerSieve(int n, vector<int>& spf) { 
    vector<int> primes; 
    for (int i = 2; i <= n; i++) { 
        if (spf[i] == 0) {  // i is prime 
            spf[i] = i; 
            primes.push_back(i); 
        } 
        for (int p : primes) { 
            if (p > spf[i] || 1LL * i * p > n) break; 
            spf[i * p] = p; 
        } 
    } 
    return primes; 
}

// Bitset Sieve (saves memory)
vector<int> bitsetSieve(int n) {
    vector<int> primes;
    bitset<1000000001> is_prime; // adjust size if needed
    is_prime.set();
    is_prime[0] = is_prime[1] = 0;
    for (int i = 2; 1LL*i*i <= n; i++) {
        if (is_prime[i]) {
            for (long long j = 1LL*i*i; j <= n; j += i)
                is_prime[j] = 0;
        }
    }
    for (int i = 2; i <= n; i++) {
        if (is_prime[i]) primes.push_back(i);
    }
    return primes;
}

// Segmented Sieve (for ranges up to 1e18)
vector<long long> segmentedSieve(long long L, long long R) {
    long long limit = sqrt(R) + 1;
    vector<int> primes = primeSieve(limit);

    vector<bool> is_prime(R - L + 1, true);
    for (long long p : primes) {
        long long start = max(p * p, ((L + p - 1) / p) * p);
        for (long long j = start; j <= R; j += p) {
            is_prime[j - L] = false;
        }
    }

    vector<long long> result;
    for (long long i = L; i <= R; i++) {
        if (i > 1 && is_prime[i - L]) result.push_back(i);
    }
    return result;
}

